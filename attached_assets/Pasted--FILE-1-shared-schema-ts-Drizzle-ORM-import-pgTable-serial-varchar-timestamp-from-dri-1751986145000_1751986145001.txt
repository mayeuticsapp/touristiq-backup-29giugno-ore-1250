// ✅ FILE 1: shared/schema.ts (Drizzle ORM)
import { pgTable, serial, varchar, timestamp } from 'drizzle-orm/pg-core';

export const temporaryCodes = pgTable('temporary_codes', {
  id: serial('id').primaryKey(),
  tempCode: varchar('temp_code', { length: 12 }).unique().notNull(),
  structureCode: varchar('structure_code', { length: 20 }).notNull(),
  guestName: varchar('guest_name', { length: 100 }),
  guestPhone: varchar('guest_phone', { length: 20 }),
  expiresAt: timestamp('expires_at').notNull(),
  usedAt: timestamp('used_at'),
  createdAt: timestamp('created_at').defaultNow(),
});


// ✅ FILE 2: server/storage.ts (Storage Layer)
export interface TempCodeData {
  structureCode: string;
  guestName?: string;
  guestPhone?: string;
}

export interface IStorage {
  generateTempCode(data: TempCodeData): Promise<string>;
  activateTempCode(tempCode: string): Promise<boolean>;
  isTempCodeUsable(tempCode: string): Promise<boolean>;
}

// Implementazione parziale come esempio
export const storage: IStorage = {
  async generateTempCode({ structureCode, guestName, guestPhone }) {
    const code = crypto.randomBytes(4).toString('hex');
    const expiresAt = new Date(Date.now() + 15 * 60 * 1000);
    await db.insert(temporaryCodes).values({
      tempCode: code,
      structureCode,
      guestName,
      guestPhone,
      expiresAt,
    });
    return code;
  },

  async activateTempCode(tempCode) {
    const now = new Date();
    const result = await db
      .select()
      .from(temporaryCodes)
      .where(and(eq(temporaryCodes.tempCode, tempCode), gt(temporaryCodes.expiresAt, now), isNull(temporaryCodes.usedAt)));

    if (result.length === 0) return false;

    await db.update(temporaryCodes).set({ usedAt: now }).where(eq(temporaryCodes.tempCode, tempCode));
    return true;
  },

  async isTempCodeUsable(tempCode) {
    const now = new Date();
    const result = await db
      .select()
      .from(temporaryCodes)
      .where(and(eq(temporaryCodes.tempCode, tempCode), gt(temporaryCodes.expiresAt, now), isNull(temporaryCodes.usedAt)));

    return result.length > 0;
  },
};


// ✅ FILE 3: server/routes.ts
import { z } from 'zod';
import { Router } from 'express';
import { storage } from '../storage';
import { requireStructureSession, requireTouristSession } from '../middleware/auth';

const router = Router();

const TempCodeSchema = z.object({
  guestName: z.string().optional(),
  guestPhone: z.string().optional(),
});

router.post('/api/structure/generate-temp-code', requireStructureSession, async (req, res) => {
  const parsed = TempCodeSchema.safeParse(req.body);
  if (!parsed.success) return res.status(400).json({ error: 'Dati non validi' });

  const tempCode = await storage.generateTempCode({
    structureCode: req.session.structure.code,
    ...parsed.data,
  });

  res.json({ tempCode });
});

router.post('/api/activate-temp-code', requireTouristSession, async (req, res) => {
  const { tempCode } = req.body;
  const valid = await storage.activateTempCode(tempCode);
  if (!valid) return res.status(400).json({ error: 'Codice non valido o scaduto' });

  res.json({ status: 'Codice attivato. Procedi con la creazione dell’IQCode' });
});

router.post('/api/create-permanent-code', requireTouristSession, async (req, res) => {
  const { tempCode, touristProfile } = req.body;
  const usable = await storage.isTempCodeUsable(tempCode);
  if (!usable) return res.status(400).json({ error: 'Codice non valido o già usato' });

  const iqCode = 'TIQ-' + crypto.randomBytes(6).toString('hex');
  await db.insert(iq_codes).values({
    code: iqCode,
    touristData: touristProfile,
    structureCode: req.session.structure.code,
  });

  res.json({ iqCode });
});
